"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInfoFilepath = exports.getLang = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
let parserArgs;
if (process_1.default.env.PRETTIER_RUBY_HOST) {
    const [cmd, ...args] = process_1.default.env.PRETTIER_RUBY_HOST.split(" ");
    parserArgs = { cmd, args };
}
// In order to properly parse ruby code, we need to tell the ruby process to
// parse using UTF-8. Unfortunately, the way that you accomplish this looks
// differently depending on your platform.
/* istanbul ignore next */
function getLang() {
    const { env, platform } = process_1.default;
    const envValue = env.LC_ALL || env.LC_CTYPE || env.LANG;
    // If an env var is set for the locale that already includes UTF-8 in the
    // name, then assume we can go with that.
    if (envValue && envValue.includes("UTF-8")) {
        return envValue;
    }
    // Otherwise, we're going to guess which encoding to use based on the system.
    // This is probably not the best approach in the world, as you could be on
    // linux and not have C.UTF-8, but in that case you're probably passing an env
    // var for it. This object below represents all of the possible values of
    // process.platform per:
    // https://nodejs.org/api/process.html#process_process_platform
    return {
        aix: "C.UTF-8",
        android: "C.UTF-8",
        cygwin: "C.UTF-8",
        darwin: "en_US.UTF-8",
        freebsd: "C.UTF-8",
        haiku: "C.UTF-8",
        linux: "C.UTF-8",
        netbsd: "C.UTF-8",
        openbsd: "C.UTF-8",
        sunos: "C.UTF-8",
        win32: ".UTF-8"
    }[platform];
}
exports.getLang = getLang;
// Generate the filepath that should be used to communicate the connection
// information between this process and the parser server.
function getInfoFilepath() {
    return path_1.default.join(os_1.default.tmpdir(), `prettier-ruby-parser-${process_1.default.pid}.info`);
}
exports.getInfoFilepath = getInfoFilepath;
// Create a file that will act as a communication mechanism, spawn a parser
// server with that filepath as an argument, then spawn another process that
// will read that information in order to enable us to connect to it in the
// spawnSync function.
function spawnServer() {
    const filepath = getInfoFilepath();
    const server = (0, child_process_1.spawn)("ruby", [path_1.default.join(__dirname, "./server.rb"), filepath], {
        env: Object.assign({}, process_1.default.env, { LANG: getLang() }),
        detached: true,
        stdio: "inherit"
    });
    server.unref();
    process_1.default.on("exit", () => {
        if ((0, fs_1.existsSync)(filepath)) {
            (0, fs_1.unlinkSync)(filepath);
        }
        try {
            if (server.pid) {
                process_1.default.kill(-server.pid);
            }
        }
        catch (e) {
            if (process_1.default.env.PLUGIN_RUBY_CI) {
                throw new Error(`Failed to kill the parser server: ${e}`);
            }
        }
    });
    const info = (0, child_process_1.spawnSync)("node", [
        path_1.default.join(__dirname, "./getInfo.js"),
        filepath
    ]);
    if (info.status !== 0) {
        throw new Error(`
      We failed to spawn our parser server. Please report this error on GitHub
      at https://github.com/prettier/plugin-ruby. The error message was:

        ${info.stderr.toString()}.
    `);
    }
    const [cmd, ...args] = info.stdout.toString().split(" ");
    return { cmd, args };
}
// If we're in a yarn Plug'n'Play environment, then the relative paths being
// used by the parser server and the various scripts used to communicate
// therein are not going to work with its virtual file system. Presumably
// there's a way to fix this but I haven't figured out how yet.
function checkPnP() {
    if (process_1.default.versions.pnp) {
        throw new Error(`
      @prettier/plugin-ruby does not current work within the yarn Plug'n'Play
      virtual file system. If you would like to help support the effort to fix
      this, please see https://github.com/prettier/plugin-ruby/issues/894.
    `);
    }
}
// Formats and sends a request to the parser server. We use netcat (or something
// like it) here since Prettier requires the results of `parse` to be
// synchronous and Node.js does not offer a mechanism for synchronous socket
// requests.
function parseSync(parser, source) {
    if (!parserArgs) {
        checkPnP();
        parserArgs = spawnServer();
    }
    const response = (0, child_process_1.spawnSync)(parserArgs.cmd, parserArgs.args, {
        input: `${parser}|${source}`,
        maxBuffer: 15 * 1024 * 1024
    });
    const stdout = response.stdout.toString();
    const stderr = response.stderr.toString();
    const { status } = response;
    // If we didn't receive anything over stdout or we have a bad exit status,
    // then throw whatever we can.
    if (stdout.length === 0 || (status !== null && status !== 0)) {
        throw new Error(stderr || "An unknown error occurred");
    }
    const parsed = JSON.parse(stdout);
    if (parsed.error) {
        const error = new Error(parsed.error);
        if (parsed.loc) {
            error.loc = parsed.loc;
        }
        throw error;
    }
    return parsed;
}
exports.default = parseSync;
